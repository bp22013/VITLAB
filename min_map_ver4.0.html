<!DOCTYPE html>
<html>
    <head>
        <title>Minimum Route Map</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@turf/turf/turf.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
        <style>
            #loading-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                color: white;
                font-size: 2em;
                font-family: sans-serif;
            }
            .loading-hidden {
                display: none !important;
            }
        </style>
    </head>
    <body>
        <div id="loading-overlay" class="loading-hidden">
            <div id="loading-message"></div>
        </div>

        <div style="display: flex; flex-direction: row; align-items: flex-start; gap: 20px;">
            <div id="map" style="width: 600px; height: 400px"></div>
            <div
                id="route-info"
                style="
                    width: 300px;
                    padding: 15px;
                    background-color: #f9f9f9;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    font-family: sans-serif;
                "
            >
                <h4>経路情報</h4>
                <p>経路を検索するとここに詳細が表示されます。</p>
            </div>
        </div>
        <button onclick="loadRouteFromCSV()">Load route from CSV</button>
        <button onclick="loadRouteFromCSV2()">Load route2 from CSV</button>
        <button onclick="clearGeoJSON()">Clear route</button>

        <button onclick="viewAREA('./RE_AREA.geojson')">対象範囲</button>
        <button onclick="displayDataFromCSV('sidewalk', 'red')">歩道</button>
        <button onclick="displayDataFromCSV('signal', 'blue')">信号</button>
        <button onclick="displayDataFromCSV('road_width1', 'purple')">道路幅1</button>
        <button onclick="displayDataFromCSV('road_width2', 'brown')">道路幅2</button>
        <button onclick="displayDataFromCSV('road_width3', 'darkgreen')">道路幅3</button>
        <button onclick="loadGeoAssign('illumination.txt','orange')">照明</button>
        <button onclick="loadGeoAssign('nature.txt','green')">自然</button>
        <button onclick="loadGeoAssign('park.txt','red')">公園</button>
        <button onclick="loadGeoAssign('garbage.txt','orange')">ごみ集積場</button>
        <button onclick="loadGeoAssign('toilet.txt','red')">公衆トイレ</button>
        <button onclick="loadGeoAssign('crosswalk1.txt','red')">横断歩道</button>
        <button onclick="loadGeoAssign('crosswalk-1.txt','red')">横断可能</button>

        <div
            id="coordinates"
            style="margin: 10px 0; padding: 10px; background-color: #f0f0f0; border-radius: 5px"
        >
            <strong>クリックした座標:</strong>
            <span id="coord-display">マップをクリックしてください</span>
        </div>

        <div>
            <h5>始点および終点を設定(地図をクリックして指定も可能)</h5>
            <label for="param1(1-181)">始点 :</label>
            <input type="text" id="param1" value="1" />
            <label for="param2(1-181)">終点 :</label>
            <input type="text" id="param2" value="246" />
        </div>
        <div>
            <h5>各条件の重みを設定(半角数字)</h5>
            <label for="weight0" style="width: 150px; display: inline-block">距離:(+)</label>
            <input
                type="range"
                id="weight0"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight0')"
            />
            <label for="textweight0"></label>
            <input type="text" id="textweight0" value="0" oninput="syncValues(this, 'weight0')" />
            <label for="weight1" style="width: 150px; display: inline-block">勾配(+):</label>
            <input
                type="range"
                id="weight1"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight1')"
            />
            <label for="textweight1"></label>
            <input
                type="text"
                id="textweight1"
                value="0"
                oninput="syncValues(this, 'textweight1')"
            />
            <br />
            <label for="weight4" style="width: 150px; display: inline-block">歩道(-):</label>
            <input
                type="range"
                id="weight4"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight4')"
            />
            <label for="textweight4"></label>
            <input type="text" id="textweight4" value="0" oninput="syncValues(this, 'weight4')" />
            <label for="weight5" style="width: 150px; display: inline-block">信号(+):</label>
            <input
                type="range"
                id="weight5"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight5')"
            />
            <label for="textweight5"></label>
            <input type="text" id="textweight5" value="0" oninput="syncValues(this, 'weight5')" />
            <br />
            <label for="weight6" style="width: 150px; display: inline-block">道路幅(+):</label>
            <input
                type="range"
                id="weight6"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight6')"
            />
            <label for="textweight6"></label>
            <input type="text" id="textweight6" value="0" oninput="syncValues(this, 'weight6')" />
            <label for="weight7" style="width: 150px; display: inline-block">照明(-):</label>
            <input
                type="range"
                id="weight7"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight7')"
            />
            <label for="textweight7"></label>
            <input type="text" id="textweight7" value="0" oninput="syncValues(this, 'weight7')" />
            <br />
            <label for="weight8" style="width: 150px; display: inline-block">自然(-):</label>
            <input
                type="range"
                id="weight8"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight8')"
            />
            <label for="textweight8"></label>
            <input type="text" id="textweight8" value="0" oninput="syncValues(this, 'weight8')" />
            <label for="weight9" style="width: 150px; display: inline-block">公園(-):</label>
            <input
                type="range"
                id="weight9"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight9')"
            />
            <label for="textweight9"></label>
            <input type="text" id="textweight9" value="0" oninput="syncValues(this, 'weight9')" />
            <br />
            <label for="weight10" style="width: 150px; display: inline-block">ごみ集積場(+):</label>
            <input
                type="range"
                id="weight10"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight10')"
            />
            <label for="textweight10"></label>
            <input type="text" id="textweight10" value="0" oninput="syncValues(this, 'weight10')" />
            <label for="weight11" style="width: 150px; display: inline-block">公衆トイレ(-):</label>
            <input
                type="range"
                id="weight11"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight11')"
            />
            <label for="textweight11"></label>
            <input type="text" id="textweight11" value="0" oninput="syncValues(this, 'weight11')" />
            <br />
            <label for="weight12" style="width: 150px; display: inline-block">横断歩道(-):</label>
            <input
                type="range"
                id="weight12"
                value="0"
                min="-100.0"
                max="100.0"
                step="0.1"
                oninput="syncValues(this, 'textweight12')"
            />
            <label for="textweight12"></label>
            <input type="text" id="textweight12" value="0" oninput="syncValues(this, 'weight12')" />
            <h5>勾配の最大許容値を設定(半角数字,単位 m/m)</h5>
            <label for="weight2" style="width: 150px; display: inline-block">上りの最大勾配:</label>
            <input
                type="range"
                id="weight2"
                value="100"
                min="0"
                max="100"
                step="0.1"
                oninput="syncValues(this, 'textweight2')"
            />
            <label for="textweight2"></label>
            <input type="text" id="textweight2" value="100" oninput="syncValues(this, 'weight2')" />
            <label for="weight3" style="width: 150px; display: inline-block">下りの最大勾配:</label>
            <input
                type="range"
                id="weight3"
                value="-100"
                min="-100"
                max="0"
                step="0.1"
                oninput="syncValues(this, 'textweight3')"
            />
            <label for="textweight3"></label>
            <input
                type="text"
                id="textweight3"
                value="-100"
                oninput="syncValues(this, 'weight3')"
            />

            <button onclick="">Set</button>
        </div>

        <script>
            var map = L.map('map', { center: [35.95017, 139.64735], zoom: 15 });
            var tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution:
                    '© <a href="http://osm.org/copyright">OpenStreetMap</a> contributors, ' +
                    '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
            });
            tileLayer.addTo(map);

            let route1Layers = [];
            let route2Layers = [];
            let otherLayers = [];
            var routeData = [];
            let route1Info = null;
            let route2Info = null;

            function updateRouteInfoDisplay() {
                const infoDiv = document.getElementById('route-info');
                let content = '<h4>経路情報</h4>';

                if (!route1Info && !route2Info) {
                    content += '<p>経路を検索するとここに詳細が表示されます。</p>';
                }

                if (route1Info) {
                    content += `
                        <div style="border: 2px solid red; padding: 8px; margin-bottom: 10px; border-radius: 5px;">
                            <h5>経路1 (赤)</h5>
                            <p style="margin: 2px 0;"><strong>総距離:</strong> ${route1Info.totalDistance.toFixed(2)} m</p>
                            <p style="margin: 2px 0;"><strong>所要時間:</strong> ${route1Info.totalTime.toFixed(2)} 分</p>
                        </div>
                    `;
                }

                if (route2Info) {
                    content += `
                        <div style="border: 2px solid blue; padding: 8px; border-radius: 5px;">
                            <h5>経路2 (青)</h5>
                            <p style="margin: 2px 0;"><strong>総距離:</strong> ${route2Info.totalDistance.toFixed(2)} m</p>
                            <p style="margin: 2px 0;"><strong>所要時間:</strong> ${route2Info.totalTime.toFixed(2)} 分</p>
                        </div>
                    `;
                }
                infoDiv.innerHTML = content;
            }

            function setLoadingState(isLoading, message = '') {
                const overlay = document.getElementById('loading-overlay');
                const messageElement = document.getElementById('loading-message');
                const controls = document.querySelectorAll('button, input');

                if (isLoading) {
                    messageElement.textContent = message;
                    overlay.classList.remove('loading-hidden');
                    controls.forEach((control) => (control.disabled = true));
                } else {
                    overlay.classList.add('loading-hidden');
                    controls.forEach((control) => (control.disabled = false));
                }
            }

            async function loadCSVData() {
                if (routeData.length > 0) return routeData;
                try {
                    const response = await fetch('./oomiya_route_inf_4.csv');
                    const csvText = await response.text();
                    const parsed = Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                    });
                    routeData = parsed.data;
                    console.log('CSVデータをロードしました:', routeData.length, '行');
                    return routeData;
                } catch (error) {
                    console.error('CSVデータのロードに失敗:', error);
                    return [];
                }
            }

            function calculateRouteInfo(resultText) {
                if (!routeData || routeData.length === 0) {
                    console.error('経路情報データ(CSV)が読み込まれていません。');
                    return null;
                }

                const segments = resultText.split('\n').filter((line) => line.trim() !== '');
                let totalDistance = 0;
                let totalTime = 0;

                const routeDataMap = new Map();
                routeData.forEach(row => {
                    if (row.node1 !== undefined && row.node2 !== undefined) {
                        routeDataMap.set(`${row.node1}-${row.node2}`, row);
                    }
                });

                segments.forEach((segment) => {
                    const fileName = segment.replace('.geojson', '');
                    const nodes = fileName.split('-');
                    if (nodes.length === 2) {
                        const node1_str = nodes[0];
                        const node2_str = nodes[1];
                        
                        let routeInfo = routeDataMap.get(`${node1_str}-${node2_str}`);
                        if (!routeInfo) {
                            routeInfo = routeDataMap.get(`${node2_str}-${node1_str}`);
                        }

                        if (routeInfo) {
                            totalDistance += routeInfo.distance || 0;
                            totalTime += routeInfo.time_minutes || 0;
                        } else {
                            console.warn(`経路情報が見つかりません: ${segment}`);
                        }
                    }
                });
                return { totalDistance, totalTime };
            }

            async function drawRouteFromResult(resultText, color, weight, routeId) {
                if (routeId === 1) {
                    route1Layers.forEach(layer => map.removeLayer(layer));
                    route1Layers = [];
                } else if (routeId === 2) {
                    route2Layers.forEach(layer => map.removeLayer(layer));
                    route2Layers = [];
                }

                const lines = resultText.split('\n').filter((line) => line.trim() !== '');
                const geojsonFiles = lines.map((line) => line.trim());
                const geojsonFolder = './oomiya_line/';

                const info = calculateRouteInfo(resultText);
                if (routeId === 1) {
                    route1Info = info;
                } else if (routeId === 2) {
                    route2Info = info;
                }
                updateRouteInfoDisplay();

                await Promise.all(
                    geojsonFiles.map((filename) =>
                        fetch(geojsonFolder + filename)
                            .then((res) => {
                                if (!res.ok) throw new Error(`${filename}の読み込みに失敗`);
                                return res.json();
                            })
                            .then((data) => {
                                const geojsonLayer = L.geoJSON(data, {
                                    style: { color: color, weight: weight, opacity: 1.0 },
                                }).addTo(map);
                                if (routeId === 1) {
                                    route1Layers.push(geojsonLayer);
                                } else {
                                    route2Layers.push(geojsonLayer);
                                }
                            })
                    )
                );
            }

            async function loadRouteFromCSV() {
                try {
                    await loadCSVData();
                    await calc();

                    const response = await fetch('result2.txt');
                    if (!response.ok)
                        throw new Error(`result2.txtの読み込みに失敗: ${response.statusText}`);
                    const newResultText = await response.text();

                    setLoadingState(true, '計算中...');

                    await drawRouteFromResult(newResultText, 'red', 10, 1);

                    const messageElement = document.getElementById('loading-message');
                    messageElement.textContent = '計算終了';

                    setTimeout(() => {
                        setLoadingState(false);
                    }, 1500);
                } catch (error) {
                    console.error('ルートの読み込みまたは計算中にエラーが発生しました:', error);
                    alert('エラーが発生しました: ' + error.message);
                    setLoadingState(false);
                }
            }

            async function loadRouteFromCSV2() {
                try {
                    await loadCSVData();
                    await calc();

                    const response = await fetch('result2.txt');
                    if (!response.ok)
                        throw new Error(`result2.txtの読み込みに失敗: ${response.statusText}`);
                    const newResultText = await response.text();

                    setLoadingState(true, '計算中...');

                    await drawRouteFromResult(newResultText, 'blue', 6, 2);

                    const messageElement = document.getElementById('loading-message');
                    messageElement.textContent = '計算終了';

                    setTimeout(() => {
                        setLoadingState(false);
                    }, 1500);
                } catch (error) {
                    console.error('ルートの読み込みまたは計算中にエラーが発生しました:', error);
                    alert('エラーが発生しました: ' + error.message);
                    setLoadingState(false);
                }
            }

            function loadGeoAssign(resultFile, color) {
                var geojsonFolder = './oomiya_line/';
                fetch(resultFile)
                    .then((response) => {
                        if (!response.ok)
                            throw new Error(
                                `Failed to fetch ${resultFile}: ${response.statusText}`
                            );
                        return response.text();
                    })
                    .then((text) => {
                        var lines = text.split('\n').filter((line) => line.trim() !== '');
                        var geojsonFiles = lines.map((line) => line.trim());
                        console.log(`Loading ${geojsonFiles.length} files from ${resultFile}`);
                        geojsonFiles.forEach(function (filename) {
                            fetch(geojsonFolder + filename)
                                .then((response) => {
                                    if (!response.ok)
                                        throw new Error(
                                            `Failed to fetch ${filename}: ${response.statusText}`
                                        );
                                    return response.json();
                                })
                                .then((data) => {
                                    var geojsonLayer = L.geoJSON(data, {
                                        style: { color: color, weight: 15, opacity: 0.2 },
                                    }).addTo(map);
                                    otherLayers.push(geojsonLayer);
                                })
                                .catch((error) =>
                                    console.error(`Error loading GeoJSON ${filename}:`, error)
                                );
                        });
                    })
                    .catch((error) => console.error(`Error loading ${resultFile}:`, error));
            }

            function drawGeoJSON(url, color, weight, opacity) {
                fetch(url)
                    .then((response) => {
                        if (!response.ok) {
                            if (response.status === 404) return null;
                            throw new Error(`Error loading GeoJSON: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then((data) => {
                        if (data) {
                            var geojsonLayer = L.geoJSON(data, {
                                style: { color: color, weight: weight, opacity: opacity },
                            }).addTo(map);
                            otherLayers.push(geojsonLayer);
                        }
                    })
                    .catch((error) => console.error(error.message));
            }

            async function displayDataFromCSV(dataType, color) {
                await loadCSVData();
                var geojsonFolder = './oomiya_line/';
                routeData.forEach(function (row) {
                    let conditionMet = false;
                    switch (dataType) {
                        case 'sidewalk':
                            if (row.sidewalk == 1) conditionMet = true;
                            break;
                        case 'signal':
                            if (row.signal == 1) conditionMet = true;
                            break;
                        case 'road_width1':
                            if (row.road_width == 1) conditionMet = true;
                            break;
                        case 'road_width2':
                            if (row.road_width == 2) conditionMet = true;
                            break;
                        case 'road_width3':
                            if (row.road_width >= 3) conditionMet = true;
                            break;
                    }
                    if (conditionMet) {
                        const filename = `${row.node1}-${row.node2}.geojson`;
                        const url = geojsonFolder + filename;
                        drawGeoJSON(url, color, 15, 0.3);
                    }
                });
            }

            function calc() {
                var param1 = document.getElementById('param1').value;
                var param2 = document.getElementById('param2').value;
                var weight0 = document.getElementById('weight0').value;
                var weight1 = document.getElementById('weight1').value;
                var weight2 = document.getElementById('weight2').value;
                var weight3 = document.getElementById('weight3').value;
                var weight4 = document.getElementById('weight4').value;
                var weight5 = document.getElementById('weight5').value;
                var weight6 = document.getElementById('weight6').value;
                var weight7 = document.getElementById('weight7').value;
                var weight8 = document.getElementById('weight8').value;
                var weight9 = document.getElementById('weight9').value;
                var weight10 = document.getElementById('weight10').value;
                var weight11 = document.getElementById('weight11').value;
                var weight12 = document.getElementById('weight12').value;
                const baseUrl = window.location.origin;
                return fetch(`${baseUrl}/calc`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `param1=${encodeURIComponent(param1)}&param2=${encodeURIComponent(
                        param2
                    )}&weight0=${encodeURIComponent(weight0)}&weight1=${encodeURIComponent(
                        weight1
                    )}&weight2=${encodeURIComponent(weight2)}&weight3=${encodeURIComponent(
                        weight3
                    )}&weight4=${encodeURIComponent(weight4)}&weight5=${encodeURIComponent(
                        weight5
                    )}&weight6=${encodeURIComponent(weight6)}&weight7=${encodeURIComponent(
                        weight7
                    )}&weight8=${encodeURIComponent(weight8)}&weight9=${encodeURIComponent(
                        weight9
                    )}&weight10=${encodeURIComponent(weight10)}&weight11=${encodeURIComponent(
                        weight11
                    )}&weight12=${encodeURIComponent(weight12)}`,
                })
                    .then((response) => {
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        return response.text();
                    })
                    .then((output) => {
                        console.log('計算完了:', output);
                    });
            }

            function clearGeoJSON() {
                [...route1Layers, ...route2Layers, ...otherLayers].forEach(layer => {
                    map.removeLayer(layer);
                });
                route1Layers = [];
                route2Layers = [];
                otherLayers = [];
                route1Info = null;
                route2Info = null;
                updateRouteInfoDisplay();
            }

            var geojsonFeatures_near = [];
            var geojsonFileNames_near = [];

            function displayCoordinates(lat, lng) {
                var coordDisplay = document.getElementById('coord-display');
                coordDisplay.innerHTML = `緯度: ${lat.toFixed(6)}, 経度: ${lng.toFixed(6)}`;
            }

            const blueIcon = new L.Icon({
                iconUrl:
                    'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                shadowUrl:
                    'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41],
            });

            let startMarker = null;

            // Load all point geojson files
            const pointPromises = [];
            for (let i = 1; i <= 300; i++) {
                // Adjust the upper limit if needed
                const fileName = `${i}.geojson`;
                const filePath = './oomiya_point/' + fileName;
                pointPromises.push(
                    fetch(filePath)
                        .then((response) => {
                            if (response.ok) {
                                return response.json().then((geojsonData) => {
                                    geojsonFeatures_near.push(geojsonData);
                                    geojsonFileNames_near.push(fileName);
                                });
                            }
                        })
                        .catch((error) => {
                            // Ignore errors for non-existent files
                        })
                );
            }

            Promise.all(pointPromises).then(() => {
                console.log(`${geojsonFeatures_near.length} points loaded.`);
            });

            map.on('click', function (e) {
                displayCoordinates(e.latlng.lat, e.latlng.lng);
                if (geojsonFeatures_near.length === 0) {
                    alert(
                        'GeoJSONデータがまだ読み込まれていません。しばらく待ってからもう一度お試しください。'
                    );
                    return;
                }

                const clickedPoint = turf.point([e.latlng.lng, e.latlng.lat]);
                let nearestPoint = null;
                let nearestFile = null;
                let minDistance = Infinity;

                geojsonFeatures_near.forEach(function (feature, index) {
                    const currentPoint = turf.point(feature.geometry.coordinates);
                    const distance = turf.distance(clickedPoint, currentPoint, {
                        units: 'kilometers',
                    });
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPoint = feature;
                        nearestFile = geojsonFileNames_near[index];
                    }
                });

                if (nearestPoint) {
                    if (startMarker) {
                        map.removeLayer(startMarker);
                    }

                    startMarker = L.marker(
                        [
                            nearestPoint.geometry.coordinates[1],
                            nearestPoint.geometry.coordinates[0],
                        ],
                        { icon: blueIcon }
                    )
                        .addTo(map)
                        .bindPopup(`始点: ${nearestFile.replace('.geojson', '')}`)
                        .openPopup();

                    document.getElementById('param1').value = nearestFile.replace('.geojson', '');
                }
            });

            function syncValues(source, targetId) {
                const target = document.getElementById(targetId);
                target.value = source.value;
            }

            async function viewAREA(filePath) {
                try {
                    const response = await fetch(filePath);
                    if (!response.ok)
                        throw new Error(`Failed to fetch GeoJSON file: ${response.statusText}`);
                    const geojsonData = await response.json();
                    var geojsonLayer = L.geoJSON(geojsonData, {
                        style: { color: 'black', weight: 8, opacity: 0.5 },
                    }).addTo(map);
                    otherLayers.push(geojsonLayer);
                } catch (error) {
                    console.error('Error loading GeoJSON:', error);
                }
            }

            window.addEventListener('load', function () {
                loadCSVData();
            });
        </script>
    </body>
</html>
